<Debug 
  chatId={currentChatId} 
  isVisible={isDev}
  on:clear="set({ rawResponseMap: {} })"
  on:loadTrackingNumber="handleCustomerMessage(event)" />

<div id="mainApp">
  <TabContent
    source={currentSource}
    trackingNumbers={normalizedTrackingData} 
    on:sendStatusClick="handleSendStatusLinkClick(event)" />
</div>

<style>
  :global(body) {
    background-color: #f3f7f9;
  }

  #mainApp {
    padding: 0 20px;
    display: flex;
    flex-direction: column;
    flex: 1;
  }
</style>

<script>
  import Livechat from '@livechat/agent-app-widget-sdk';
  import debounce from 'lodash.debounce';
  import { upsRegex, capitalize } from './helpers';
  import renderWidgets from './widgetRenderer';
  import trackingSelector from './trackingSelector';
  import TabContent from './TabContent.html';
  import Debug from './Debug';

  const currentCacheVersion = 1;
  const isDev = false;
  const host = isDev ? 'https://go-proxy-lc.herokuapp.com' : 'https://go-proxy-prod-lc.herokuapp.com/';

  export default {
    data() {
      return {
        /**
          rawResponseMap has this format:
          {
            CHAT_ID: {
              __id: number // ascending, so we know which chat is recent (for cache),
              TRACKING_NUMBER: { // tracking number found in message
                __id: number // same as above, but for the purpose of sorting tracking numbers,
                ...properties // all properties of the raw API response
              }
            }
          }
        **/
        rawResponseMap: {},
        normalizedTrackingData: [],
        currentChatId: '',
        currentSource: '',
        isDev: isDev
      };
    },

    oncreate() {
      this.syncStateCache();

      this.handleCustomerProfile = this.handleCustomerProfile.bind(this);
      Livechat.on("customer_profile", this.handleCustomerProfile);

      this.handleCustomerMessage = this.handleCustomerMessage.bind(this);
      Livechat.on('message', this.handleCustomerMessage);

      this.handleButtonClickMessage = this.handleButtonClickMessage.bind(this);
      Livechat.on('customer_details_section_button_click', this.handleButtonClickMessage);

      // app can be displayed in different sections, each section has its own instance of this app
      // so we need to sync the state between them
      this.syncStateCache = this.syncStateCache.bind(this);
      window.addEventListener('storage', this.syncStateCache);
    },

    onupdate() {
      this.debouncedUpdate();
    },

    ondestroy() {
      Livechat.off('customer_profile', this.handleCustomerProfile);
      Livechat.off('message', this.handleCustomerMessage);
      Livechat.off('customer_details_section_button_click', this.handleButtonClickMessage);
      window.removeEventListener('storage', this.syncStateCache);
    },

    methods: {
      debouncedUpdate: debounce(function() {
        const { normalizedTrackingData, rawResponseMap, currentSource } = this.get();
        
        // render widgets in Customer Details
        renderWidgets(normalizedTrackingData, currentSource);

        // save stateCache on every change
        localStorage.setItem('stateCache', JSON.stringify({
          // limit how many items we put in the cache
          ...this.truncateResponseMap(rawResponseMap),
          __version: currentCacheVersion
        }));
      }, 200, { leading: true, trailing: true }),

      syncStateCache() {
        let stateCache = JSON.parse(localStorage.getItem('stateCache') || '{}');

        if (stateCache.__version !== currentCacheVersion) {
          // bust cache
          stateCache = {};
          localStorage.clear();
        }

        this.set({ rawResponseMap: stateCache });
      },

      truncateResponseMap(rawResponseMap) {
        return Object.entries(rawResponseMap)
          .filter(([_, chatMap]) => chatMap && typeof chatMap === 'object')
          // sort descending
          .sort((a, b) => b[1].__id - a[1].__id)
          // get last X chats
          .slice(0, 50)
          // turn back into map
          .reduce((acc, [chatId, chatMap]) => {
            acc[chatId] = chatMap;
            return acc;
          }, {});
      },

      handleCustomerProfile({ chat: { id: chatId }, source }) {
        this.set({ currentChatId: chatId, currentSource: source });
      },

      handleSendStatusLinkClick(trackingNumber) {
        const { status } = this.getTrackingObject(trackingNumber);
        
        if (status && status.value) {
          Livechat.putMessage(this.createMessageForAgent(trackingNumber, status.value));
        }
      },

      handleButtonClickMessage({ buttonId }) {
        const [ buttonType, value ] = buttonId.split('-');
        const { status, errorDescription } = this.getTrackingObject(value);
        const statusText = errorDescription.value || status.value;
        
        if (buttonType === 'sendstatus' && statusText) {
          Livechat.putMessage(this.createMessageForAgent(value, statusText));
        }
      },

      async handleCustomerMessage(messageData) {
        const { message, message_source } = messageData;
        if (message_source !== 'visitor') {
          return;
        }

        // search for tracking numbers in the user's message
        const regexResult = message.match(upsRegex);
        if (!regexResult) {
          return;
        }

        const results = regexResult;
        if (!results.length) {
          return;
        }

        for (const trackingNumber of results) {
          await this.fetchTrackingData(trackingNumber, messageData);
        }
      },

      async fetchTrackingData(trackingNumber, messageData, attempt = 0) {
        const trackingUrl = `${host}/ups?tracking=${trackingNumber}`;

        try {
          const response = await fetch(trackingUrl);
          const json = await response.json();
          const errorCode = trackingSelector.getErrorCode(json);

          // API sometimes doesn't work, workaround:
          if (errorCode === '10001' && attempt < 5) {
            console.info(`Attempt #[${attempt}] - Retrying to fetch from UPS API.`)
            return this.fetchTrackingData(trackingNumber, messageData, attempt + 1);
          }

          const { chat } = messageData;
          this.set({ rawResponseMap: this.updateResponseForChat(chat, trackingNumber, json) });
        } catch (e) {
          console.error(e);
        }
      },

      updateResponseForChat(chat, trackingNumber, trackingObject) {
        const { rawResponseMap } = this.get();
        const newResponseMap = { ...rawResponseMap };

        if (!newResponseMap[chat]) {
          newResponseMap[chat] = {};
          const rawResponseList = Object.keys(newResponseMap).map(key => newResponseMap[key]);
          const maxId = Math.max(...rawResponseList.map(item => item.__id || 1));
          newResponseMap[chat].__id = maxId + 1;
        }

        const rawResponseMapForChat = newResponseMap[chat];
        const keyLength = Object.keys(rawResponseMapForChat).length;
        rawResponseMapForChat[trackingNumber] = { __id: keyLength + 1, ...trackingObject };
        return newResponseMap;
      },

      createMessageForAgent(trackingNumber, status) {
        return `${trackingNumber}\nPackage status:\n${capitalize(status)}`;
      },

      getTrackingObject(query) {
        const { normalizedTrackingData } = this.get();
        return normalizedTrackingData.find(({ trackingNumber }) => trackingNumber.value === query);
      }
    },

    computed: {
      normalizedTrackingData: ({ rawResponseMap, currentChatId }) => {
        if (!currentChatId) {
          return [];
        }
        
        const rawResponseMapForChat = rawResponseMap[currentChatId] || {};
        const result = Object.keys(rawResponseMapForChat)
          // filter out so that normalize function doesn't take this key into account
          .filter(key=> !key.includes('__'))
          // map into [trackingNumber, rawResponse] array so we can sort it
          .map(trackingNumber => [trackingNumber, rawResponseMapForChat[trackingNumber]])
          // sort descending
          .sort((a, b) => b[1].__id - a[1].__id)
          // map into normalized response
          .map(([trackingNumber, rawResponse]) => trackingSelector.getNormalizedResponse(trackingNumber, rawResponse))
        return [].concat(...result);
      }
    },

    components: {
      TabContent,
      Debug
    }
  };
</script>
